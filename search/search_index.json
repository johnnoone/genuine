{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A tour of genuine","text":"<p>Genuine is a fixture generator for model object inspired by ruby factory_bot and elixir ex_machina.</p> <p>It makes it easy to create test data and associations for dataclasses. Install genuine and then you will be able to use it without configuration:</p> <pre><code>from dataclasses import dataclass\nfrom genuine import build\n\n@dataclass\nclass User:\n    name: str\n    age: int\n    admin: bool = False\n\nuser = build(User)\nassert isinstance(user, User)\n</code></pre> <p>You can also generate a list of objects</p> <pre><code>from genuine import build_many\n\nusers = build_many(2, User)\nassert len(users) == 2\n</code></pre> <p>In these examples, <code>name</code> and <code>age</code> are auto generated, infered from object annotations. Will it is the default behavior, rendered values can be overriten:</p> <pre><code>user = build(User, overrides={\"name\": \"John\"})\nassert user.name == \"John\"\n</code></pre> <p>But it doesn't seem natural that all objects have the same name, does it? You can some smart randomness to this attribute.</p> <p>For example you can use the Cycle helper that will return a value cyclicly:</p> <pre><code>from genuine import Cycle\n\nusers = build_many(3, User, overrides={\"name\": Cycle([\"John\", \"Dave\"])})\nassert users[0].name == \"John\"\nassert users[1].name == \"Dave\"\nassert users[2].name == \"John\"\n</code></pre> <p>Or use an fixture library like faker or mimesis that will make it smoothly for you:</p> <pre><code>from mimesis import Generic\nfrom genuine import Computed\n\ng = Generic()\n\nname_generator = Computed(lambda: g.person.name())\nusers = build_many(3, User, overrides={\"name\": name_generator})\nassert user[0].name != user[1].name != user[2].name\n</code></pre>"},{"location":"#persist-data","title":"Persist data","text":"<p>Often you want to persist your model object somewhere. This is where the <code>create</code> and <code>create_many</code> helpers come from.</p> <pre><code>from genuine import create, Context\n\nPERSISTED = []\n\ndef persist(instance: User, context: Context):\n    PERSISTED.append(instance)\n\nuser = create(User, storage=persist)\nassert user in PERSISTED\n</code></pre>"},{"location":"#factories","title":"Factories","text":"<p>OK, we saw that <code>overrides</code> let you fine tune the value of attributes. but it's long and tiring to always include it, especially when you always want the same thing.</p> <p>This is why you can define factories to teach genuine what plausible values it should use to build instances.</p> <p>For example, those 2 scenarios have the same result:</p> <pre><code>name_generator = Cycle([\"John\", \"Dave\"])\nuser = build(User, overrides={\"name\": name_generator})\nuser = build(User, overrides={\"name\": name_generator})\nuser = build(User, overrides={\"name\": name_generator})\nuser = build(User, overrides={\"name\": name_generator})\n</code></pre> <pre><code>from genuine import define_factory\n\nwith define_factory(User) as factory:\n    factory.set(\"name\", Cycle([\"John\", \"Dave\"]))\n\nuser = build(User)\nuser = build(User)\nuser = build(User)\nuser = build(User)\n</code></pre> <p>Defining factories allows you to reuse them everywhere in your tests.</p> <p>But that's not all. instances sometimes have to be like this or like that. Factories allow you to also define different <code>traits</code> for the same model object:</p> <pre><code>with define_factory(User) as factory:\n    factory.set(\"name\", name_generator)\n    with factory.trait(\"regular\") as trait:\n        trait.set(\"admin\", False)\n    with factory.trait(\"admin\") as trait:\n        trait.set(\"admin\", True)\n\nassert build(User, \"regular\").admin is False\nassert build(User, \"admin\").admin is True\n</code></pre> <p>Traits are a mechanism when there is little things that change.</p> <p>You can also define derived factories using <code>derived_factory</code>, for example:</p> <pre><code>with define_factory(User) as main:\n    main.set(\"name\", name_generator)\n    main.set(\"admin\", False)\n\n    with main.derived_factory(\"admin\") as derived:\n        derived.set(\"admin\", True)\n\nassert build(User).admin is False\nassert build(User, \"admin\").admin is True\n</code></pre> <p>Finally you are able to define specialized factories for the same model:</p> <pre><code>with define_factory(User) as factory:\n    ...\n\nwith define_factory(User, \"admin\") as factory:\n    ...\n\nassert build(User).admin is False\nassert build(User, \"admin\").admin is True\n</code></pre>"},{"location":"#context-and-transient","title":"Context and transient","text":"<p>Factories let you declare some context data that will help you to fine tune you instances.</p> <p>Let's say sometime you need to uppercase name:</p> <pre><code>with define_factory(User) as factory:\n    factory.set(\"name\", Computed(lambda uppercased: \"BIG JOHN\" if uppercased else \"Regular John\"))\n    with factory.transient() as transient:\n        transient.set(\"uppercased\", False)\n\nassert build(User).name == \"Regular John\"\nassert build(User, overrides={\"uppercased\": True}).name== \"BIG JOHN\"\n</code></pre> <p>Those instance attributes and transient data are passed into <code>Context</code> object. This object will help you to define complexe scenarios. It is exposed into helper functions like persist, hooks and refinement.</p> <p>For example, the previous factory will generate those Context:</p> <pre><code>build(User, overrides={\"uppercased\": False})  # --&gt; Context({\"name\": \"Regular John\", \"uppercased\": False})\nbuild(User, overrides={\"uppercased\": True})  # --&gt; Context({\"name\": \"Regular John\", \"uppercased\": True})\n</code></pre>"},{"location":"#nested-model-objects","title":"Nested model objects","text":"<p>Comment have commenter, right? This is what we call a sub object.</p> <p>With factory bot, those objects can be declared easily to, with associations:</p> <pre><code>@dataclass\nclass Comment:\n    commenter: Author\n\n\nwith define_factory(Comment) as factory:\n    factory.associate(\"commenter\", User)\n\ncommenter = build(Comment).commenter\nassert isinstance(commenter, User)\n</code></pre> <p>You can override nested objects too:</p> <pre><code>comment = build(Comment, override={\"commenter\": Overrides({\"name\": \"Mickey\"})})\nassert comment.commenter.name == \"Mickey\"\n</code></pre> <p>Note that by default, nested objects are always created. This behavior can be configured within <code>association</code>, or with <code>Overrides</code> object, using <code>Strategy</code> enum.</p> <pre><code>with define_factory(Comment) as factory:\n    factory.associate(\"commenter\", User, strategy=Strategy.BUILD)\n</code></pre> <pre><code>build(Comment, overrides={\"commenter\": Overrides(strategy=Strategy.BUILD)})\n</code></pre>"},{"location":"#hooks-and-refinement","title":"Hooks and refinement","text":"<p>You can declare some hooks that will be applied during the construction of the object.</p> <pre><code>with define_factory(User) as factory:\n    @factory.hook(\"after_build\")\n    def _(instance: User, context: Context):\n        print(\"called after_build\")\n\n    @factory.hook(\"before_create\")\n    def _(instance: User, context: Context):\n        print(\"called before_create\")\n\n    @factory.hook(\"after_create\")\n    def _(instance: User, context: Context):\n        print(\"called after_create\")\n\ncreate(User)\n# prints\n# called after_build\n# called before_create\n# called after_create\n</code></pre> <p>And you can define a refinement function at the end of the function</p> <pre><code>build(User, refine=lambda instance, context: print(\"called refine\"))\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"api/#genuine.bases.Genuine.define_factory","title":"define_factory","text":"<pre><code>define_factory(model, aliases=None, /, *, storage=Absent())\n</code></pre> RETURNS DESCRIPTION <code>FactoryDSL</code> <p>The definition of factory</p> PARAMETER  DESCRIPTION <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>aliases</code> <p>Alias attached to this factory.</p> <p>For example if you open you definition like this:</p> <pre><code>with define_factory(User, \"account\") as factory:\n    ...\n\nbuild(User, \"account\")\n</code></pre> <p>it will match the previous definition.</p> <p>If alias is missing, it will target the main factory.</p> <p>You can also define multiple factories at once, using this syntaxe:</p> <pre><code>with define_factory(User, {\"alias1\", \"alias2\", \"alias3\"}) as factory:\n    ...\n\nbuild(User, \"alias1\")\nbuild(User, \"alias2\")\nbuild(User, \"alias3\")\n</code></pre> <p> TYPE: <code>Iterable[str | None] | str | None</code> DEFAULT: <code>None</code> </p> <code>storage</code> <p>Let define how instances will be persisted when using <code>create</code> and <code>create_many</code></p> <p> TYPE: <code>Persist[Any] | None | AbsentSentinel</code> DEFAULT: <code>Absent()</code> </p>"},{"location":"api/#genuine.bases.Genuine.build","title":"build","text":"<pre><code>build(\n    model,\n    *specializations,\n    overrides=None,\n    refine=lambda: None\n)\n</code></pre> <p>Build one model instance.</p> <pre><code>user = build(User)\nassert isinstance(user, User)\n</code></pre> PARAMETER  DESCRIPTION <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*specializations</code> <p>Where the first value is the factory alias, and the others are traits</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>refine</code> <p> TYPE: <code>Refine[T]</code> DEFAULT: <code>lambda : None</code> </p>"},{"location":"api/#genuine.bases.Genuine.build_many","title":"build_many","text":"<pre><code>build_many(\n    count,\n    /,\n    model,\n    *specializations,\n    overrides=None,\n    refine=lambda: None,\n)\n</code></pre> <p>Build many model instances.</p> <pre><code>user1, user2 = build_many(2, User)\nassert isinstance(user1, User)\nassert isinstance(user2, User)\n</code></pre> PARAMETER  DESCRIPTION <code>count</code> <p> TYPE: <code>int</code> </p> <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*specializations</code> <p>Where the first value is the factory alias, and the others are traits</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>refine</code> <p> TYPE: <code>Refine[T]</code> DEFAULT: <code>lambda : None</code> </p>"},{"location":"api/#genuine.bases.Genuine.create","title":"create","text":"<pre><code>create(\n    model,\n    *specializations,\n    overrides=None,\n    refine=lambda: None,\n    storage=None\n)\n</code></pre> <p>Create one model instance.</p> <pre><code>user = create(User)\nassert isinstance(user, User)\n</code></pre> PARAMETER  DESCRIPTION <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*specializations</code> <p>Where the first value is the factory alias, and the others are traits</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>refine</code> <p> TYPE: <code>Refine[T]</code> DEFAULT: <code>lambda : None</code> </p> <code>storage</code> <p>Tell how the instance is persisted.</p> <p>When not set, fallback to the one defined by <code>define_factory</code></p> <p> TYPE: <code>Persist[T] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Genuine.create_many","title":"create_many","text":"<pre><code>create_many(\n    count,\n    /,\n    model,\n    *specializations,\n    overrides=None,\n    refine=lambda: None,\n    storage=None,\n)\n</code></pre> <p>Create many model instances.</p> <pre><code>user1, user2 = create_many(2, User)\nassert isinstance(user1, User)\nassert isinstance(user2, User)\n</code></pre> PARAMETER  DESCRIPTION <code>count</code> <p> TYPE: <code>int</code> </p> <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*specializations</code> <p>Where the first value is the factory alias, and the others are traits</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>refine</code> <p> TYPE: <code>Refine[T]</code> DEFAULT: <code>lambda : None</code> </p> <code>storage</code> <p>Tell how instances are persisted.</p> <p>When not set, fallback to the one defined by <code>define_factory</code></p> <p> TYPE: <code>Persist[T] | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Genuine.attributes_for","title":"attributes_for","text":"<pre><code>attributes_for(model, *specializations, overrides=None)\n</code></pre> <p>Get attributes for one model instance</p> PARAMETER  DESCRIPTION <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*specializations</code> <p>Where the first value is the factory alias, and the others are traits</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Attributes","title":"Attributes  <code>module-attribute</code>","text":"<pre><code>Attributes = Mapping[str, Any]\n</code></pre> <p>Collected attributes of model object.</p> <p>For example for this object:</p> <pre><code>@dataclass\nclass User:\n    given_name: str\n    family_name: str\n    age: int\n</code></pre> <p>This container should looks like:</p> <pre><code>{\"given_name\": \"John\", \"family_name\": \"Smith\", \"age\": 45}\n</code></pre>"},{"location":"api/#genuine.bases.Computed","title":"Computed  <code>dataclass</code>","text":"<p>             Bases: <code>ValueProvider[T]</code></p>"},{"location":"api/#genuine.bases.Computed.random","title":"random  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>random = field(kw_only=True, default=random)\n</code></pre>"},{"location":"api/#genuine.bases.Computed.dependencies","title":"dependencies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dependencies = field(kw_only=True, default_factory=list)\n</code></pre>"},{"location":"api/#genuine.bases.Computed.wrapped","title":"wrapped  <code>instance-attribute</code>","text":"<pre><code>wrapped\n</code></pre>"},{"location":"api/#genuine.bases.Computed.__call__","title":"__call__","text":"<pre><code>__call__(context=None)\n</code></pre> PARAMETER  DESCRIPTION <code>context</code> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Cycle","title":"Cycle  <code>dataclass</code>","text":"<p>             Bases: <code>ValueProvider[T]</code></p>"},{"location":"api/#genuine.bases.Cycle.random","title":"random  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>random = field(kw_only=True, default=random)\n</code></pre>"},{"location":"api/#genuine.bases.Cycle.dependencies","title":"dependencies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dependencies = field(kw_only=True, default_factory=list)\n</code></pre>"},{"location":"api/#genuine.bases.Cycle.values","title":"values  <code>instance-attribute</code>","text":"<pre><code>values\n</code></pre>"},{"location":"api/#genuine.bases.Cycle.__call__","title":"__call__","text":"<pre><code>__call__(context=None)\n</code></pre> PARAMETER  DESCRIPTION <code>context</code> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Cycle.__next__","title":"__next__","text":"<pre><code>__next__()\n</code></pre>"},{"location":"api/#genuine.bases.Sequence","title":"Sequence  <code>dataclass</code>","text":"<p>             Bases: <code>ValueProvider[T]</code></p>"},{"location":"api/#genuine.bases.Sequence.random","title":"random  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>random = field(kw_only=True, default=random)\n</code></pre>"},{"location":"api/#genuine.bases.Sequence.dependencies","title":"dependencies  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dependencies = field(kw_only=True, default_factory=list)\n</code></pre>"},{"location":"api/#genuine.bases.Sequence.wrapped","title":"wrapped  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wrapped = field(default=lambda : x)\n</code></pre> <p>Any callable where first argument is the index of the sequence counter, and other arguments are members of <code>Context</code>.</p> <p>For example, a simple counter:</p> <pre><code>seq = Sequence(lambda i: f\"rank#{i}\")\nassert seq() == \"rank#0\"\nassert seq() == \"rank#1\"\nassert seq() == \"rank#2\"\n</code></pre> <p>Generate email based on instance.name and counter index:</p> <pre><code>seq = Sequence(lambda i, name: f\"{name}.{i}@example.com\".lower)\nassert seq({\"name\": \"John\"}) == \"john.0@example.com\"\nassert seq({\"name\": \"John\"}) == \"john.1@example.com\"\nassert seq({\"name\": \"Dave\"}) == \"dave.2@example.com\"\n</code></pre>"},{"location":"api/#genuine.bases.Sequence.i","title":"i  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>i = 0\n</code></pre>"},{"location":"api/#genuine.bases.Sequence.__call__","title":"__call__","text":"<pre><code>__call__(context=None)\n</code></pre> PARAMETER  DESCRIPTION <code>context</code> <p> TYPE: <code>Context | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.Name","title":"Name  <code>module-attribute</code>","text":"<pre><code>Name = tuple[type[T], str | None]\n</code></pre> <p>Identifier of factory.</p> <p>Can be only the model class, or a tuple of model class, profile.</p> <p>For example:</p> <pre><code>User\n(User, \"admin\")\n</code></pre> <p>Those two identifier are equivalents:</p> <pre><code>User\n(User, None)\n</code></pre>"},{"location":"api/#genuine.bases.Persist","title":"Persist","text":"<p>             Bases: <code>Protocol[T_contrat]</code></p>"},{"location":"api/#genuine.bases.Persist.__call__","title":"__call__","text":"<pre><code>__call__(instance, context)\n</code></pre> PARAMETER  DESCRIPTION <code>instance</code> <p> TYPE: <code>T_contrat</code> </p> <code>context</code> <p> TYPE: <code>Context</code> </p>"},{"location":"api/#genuine.bases.MaybeOverrides","title":"MaybeOverrides  <code>module-attribute</code>","text":"<pre><code>MaybeOverrides = Mapping[str, Any] | None\n</code></pre>"},{"location":"api/#genuine.bases.Refine","title":"Refine  <code>module-attribute</code>","text":"<pre><code>Refine = Callable[[T], Any]\n</code></pre>"},{"location":"api/#genuine.bases.UserHook","title":"UserHook  <code>module-attribute</code>","text":"<pre><code>UserHook = Callable[[Any, Any], Any]\n</code></pre> <p>Any callable that has 2 parameters: instance and context.</p> PARAMETER  DESCRIPTION <code>instance</code> <p>the instance being build</p> <p> TYPE: <code>T</code> </p> <code>context</code> <p>the context</p> <p> TYPE: <code>Context</code> </p> <p>Example:</p> <pre><code>@factory.add_hook(\"after_create\", lambda instance, context: instance.tags.append(\"new-tag\"))\n</code></pre>"},{"location":"api/#genuine.bases.Context","title":"Context  <code>module-attribute</code>","text":"<pre><code>Context = Mapping[str, Any]\n</code></pre> <p>Set of attributes currently being collected and transient data.</p>"},{"location":"api/#genuine.bases.FactoryDSL","title":"FactoryDSL  <code>dataclass</code>","text":""},{"location":"api/#genuine.bases.FactoryDSL.set","title":"set","text":"<pre><code>set(attr, /, value)\n</code></pre> <p>Set a value for <code>attr</code>.</p> <p>Value may be anything.</p> <p>Using Computed, it can be based on other attributes or transient data.</p> PARAMETER  DESCRIPTION <code>attr</code> <p> TYPE: <code>str</code> </p> <code>value</code> <p> TYPE: <code>Any | Computed[Any] | Cycle[Any] | Sequence[Any] | RandomValue[Any]</code> </p>"},{"location":"api/#genuine.bases.FactoryDSL.associate","title":"associate","text":"<pre><code>associate(\n    attr, model, *traits, overrides=None, strategy=None\n)\n</code></pre> PARAMETER  DESCRIPTION <code>attr</code> <p> TYPE: <code>str</code> </p> <code>model</code> <p> TYPE: <code>type[Any]</code> </p> <code>*traits</code> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p> TYPE: <code>Strategy | None</code> DEFAULT: <code>None</code> </p>"},{"location":"api/#genuine.bases.FactoryDSL.transient","title":"transient","text":"<pre><code>transient()\n</code></pre> RETURNS DESCRIPTION <code>TransientDSL</code> <p>The definition of factory</p>"},{"location":"api/#genuine.bases.FactoryDSL.trait","title":"trait","text":"<pre><code>trait(name)\n</code></pre> RETURNS DESCRIPTION <code>TraitDSL</code> <p>The definition of factory</p> PARAMETER  DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p>"},{"location":"api/#genuine.bases.FactoryDSL.add_hook","title":"add_hook","text":"<pre><code>add_hook(name, callback)\n</code></pre> <p>Register a hook Example:</p> <pre><code>factory.add_hook(\"after_build\", lambda instance, context: ...)\n</code></pre> PARAMETER  DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>callback</code> <p> TYPE: <code>UserHook</code> </p>"},{"location":"api/#genuine.bases.FactoryDSL.hook","title":"hook","text":"<pre><code>hook(name)\n</code></pre> <p>Decorator used to register hook</p> PARAMETER  DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Callable[[UserHook], None]</code> <p>decorator</p> <p>Example:</p> <pre><code>@factory.hook(\"after_build\")\ndef _(instance, context):\n    pass\n</code></pre>"},{"location":"api/#genuine.bases.FactoryDSL.derived_factory","title":"derived_factory","text":"<pre><code>derived_factory(aliases, /, storage=Absent())\n</code></pre> <p>Define a sub factory that inherits from current.</p> PARAMETER  DESCRIPTION <code>aliases</code> <p> TYPE: <code>Iterable[str] | str</code> </p> <code>storage</code> <p> TYPE: <code>Persist[T] | None | AbsentSentinel</code> DEFAULT: <code>Absent()</code> </p> RETURNS DESCRIPTION <code>FactoryDSL</code> <p>The definition of factory</p>"},{"location":"api/#genuine.bases.TransientDSL","title":"TransientDSL  <code>dataclass</code>","text":""},{"location":"api/#genuine.bases.TransientDSL.set","title":"set","text":"<pre><code>set(attr, /, value)\n</code></pre> PARAMETER  DESCRIPTION <code>attr</code> <p> TYPE: <code>str</code> </p> <code>value</code> <p> TYPE: <code>Any | Computed[Any] | Cycle[Any] | Sequence[Any]</code> </p>"},{"location":"api/#genuine.bases.TraitDSL","title":"TraitDSL  <code>dataclass</code>","text":""},{"location":"api/#genuine.bases.TraitDSL.set","title":"set","text":"<pre><code>set(attr, /, value)\n</code></pre> PARAMETER  DESCRIPTION <code>attr</code> <p> TYPE: <code>str</code> </p> <code>value</code> <p> TYPE: <code>Any | Computed[Any] | Cycle[Any] | Sequence[Any]</code> </p>"},{"location":"api/#genuine.bases.TraitDSL.add_hook","title":"add_hook","text":"<pre><code>add_hook(name, callback)\n</code></pre> PARAMETER  DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>callback</code> <p> TYPE: <code>UserHook</code> </p>"},{"location":"api/#genuine.bases.TraitDSL.hook","title":"hook","text":"<pre><code>hook(name)\n</code></pre> PARAMETER  DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p>"},{"location":"api/#genuine.bases.TraitDSL.transient","title":"transient","text":"<pre><code>transient()\n</code></pre> RETURNS DESCRIPTION <code>TransientDSL</code> <p>The definition of factory</p>"},{"location":"api/#genuine.bases.TraitDSL.associate","title":"associate","text":"<pre><code>associate(\n    attr, model, *traits, overrides=None, strategy=None\n)\n</code></pre> PARAMETER  DESCRIPTION <code>attr</code> <p> TYPE: <code>str</code> </p> <code>model</code> <p> TYPE: <code>type[T]</code> </p> <code>*traits</code> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>overrides</code> <p> TYPE: <code>MaybeOverrides</code> DEFAULT: <code>None</code> </p> <code>strategy</code> <p> TYPE: <code>Strategy | None</code> DEFAULT: <code>None</code> </p>"},{"location":"factories/","title":"Factories","text":""},{"location":"factories/#setting-values","title":"Setting values","text":"<p>Factories allow you to define each attributes precisely</p>"},{"location":"factories/#as-is","title":"As-is","text":"<pre><code>@dataclass\nclass User:\n    name: str\n    age: int\n    date_of_birth: date\n\nwith define_factory(User) as factory:\n    factory.set(\"name\", \"Billy Pangolin\")\n</code></pre> <p>With this definition, <code>name</code> will always be \"Billy Pangolin\".</p>"},{"location":"factories/#cycle","title":"Cycle","text":"<pre><code>with define_factory(User) as factory:\n    factory.set(\"name\", Cycle([\"Billy Pangolin\", \"Bob Aardvark\"]))\n</code></pre> <p>With this definition, <code>name</code> will alternate cyclically between \"Billy Pangolin\" and \"Bob Aardvark\".</p>"},{"location":"factories/#computed","title":"Computed","text":"<pre><code>with define_factory(User) as factory:\n    factory.set(\"age\", Computed(lambda date_of_birth: date.today().year - date_of_birth.year))\n</code></pre> <p>With this definition, <code>age</code> will depends on the value of <code>date_of_birth</code>.</p>"},{"location":"factories/#randomvalues","title":"RandomValues","text":"<pre><code>with define_factory(User) as factory:\n    factory.set(\"name\", RandomValue([\"Billy Pangolin\", \"Bob Aardvark\"]))\n</code></pre> <p>With this definition, <code>name</code> will be randomly set to \"Billy Pangolin\" or \"Bob Aardvark\".</p>"},{"location":"factories/#transient-data","title":"Transient data","text":"<p>Used with <code>Computed</code>, it allow to make attributes depend on non-instance data.</p> <p>For example:</p> <pre><code>with define_factory(User) as factory:\n    factory.set(\"name\", Computed(lambda uppercased: \"BIG JOHN\" if uppercased else \"John\"))\n    factory.transient().set(\"uppercased\", False)\n\nassert build(User).name == \"John\"\nassert build(User, overrides={\"uppercased\": True}).name == \"BIG JOHN\"\n</code></pre>"},{"location":"factories/#associations","title":"Associations","text":"<p>TODO</p>"},{"location":"factories/#specialisation","title":"Specialisation","text":"<p>A same model can be defined several times using aliases.</p> <p>For example, you have a single model Character that is used for different roles:</p> <pre><code>@dataclass\nclass Character:\n    name: str\n    house: Literal[\"lannister\", \"stark\", \"targaryen\"]\n</code></pre> <p>Everytime you need a new character your have to repeat those configurations</p> <pre><code>build(Character, overrides={\"name\": \"Danaerys\", \"house\": \"targaryen\"})\nbuild(Character, overrides={\"name\": \"Cersei\", \"house\": \"lannister\"})\nbuild(Character, overrides={\"name\": \"Eddard\", \"house\": \"stark\"})\n</code></pre> <p>It's cumbersome and error-prone.</p> <p>Aliases allow you to define different factories for the same model, for example:</p> <pre><code>with define_factory(Character, \"targaryen\") as factory:\n    factory.set(\"name\", RandomValue([\"Danaerys\", \"Rhaegar\", \"Rhaenyra\"]))\n    factory.set(\"house\", \"targaryen\")\n\nwith define_factory(Character, \"lannister\") as factory:\n    factory.set(\"name\", RandomValue([\"Cersei\", \"Tyrion\", \"Tywin\"]))\n    factory.set(\"house\", \"lannister\")\n\nwith define_factory(Character, \"stark\") as factory:\n    factory.set(\"name\", RandomValue([\"Eddard\", \"Arya\", \"Sansa\"]))\n    factory.set(\"house\", \"stark\")\n</code></pre> <p>Each factory will produce a consistent object with little configuration:</p> <pre><code>build(Character, \"targaryen\")\nbuild(Character, \"lannister\")\nbuild(Character, \"stark\"))\n</code></pre>"},{"location":"factories/#derivations","title":"Derivations","text":"<p>TODO</p>"},{"location":"factories/#traits","title":"Traits","text":"<p>TODO</p>"},{"location":"factories/#how-are-collected-values","title":"How are collected values?","text":"<p>TODO</p> <ol> <li>loop from the most distant to the current factory</li> <li>per factory<ol> <li>take all attributes definition</li> <li>resolve all traits found</li> </ol> </li> </ol>"},{"location":"factories/#singletons","title":"Singletons","text":"<p>Factories are singletons. Several calls to <code>define_factory</code> will return the same instance:</p> <pre><code>@dataclass\nclass User:\n    given_name: str\n    family_name: str\n    age: int\n\nwith define_factory(User) as factory:\n    factory.set(\"given_name\", \"John\")\n\nwith define_factory(User) as factory:\n    factory.set(\"family_name\", \"Smith\")\n\nwith define_factory(User) as factory:\n    factory.set(\"age\", 45)\n\nassert build(User) == User(\"John\", \"Smith\", 45)\n</code></pre>"},{"location":"integrations/","title":"Integrations","text":"<p>Works with pytest-randomly.</p>"}]}